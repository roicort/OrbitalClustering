% !TEX root = ../my-thesis.tex
%
\chapter{Método propuesto}
\label{chapter:4}

%\cleanchapterquote{Innovation distinguishes between a leader and a follower.}{Steve Jobs}{(CEO Apple Inc.)}

El agrupamiento de una colección de grafos no es un problema sencillo. El uso de algoritmos de agrupación populares, como KMeans, requiere representar los grafos en un espacio vectorial. Esta tarea puede llevarse a cabo mediante métodos que van desde la extracción de características hasta \textit{embeddings} más sofisticados, generados a través de redes neuronales. 

Priorizando la interpretación de los resultados, proponemos usar el conteo de órbitas en \textit{graphlets} dirigidos para hacer una caracterización de los usuarios en la colección analizada y crear un \textit{embedding} de las redes que brinde información sobre el tipo de comportamiento que genera un determinado tema. 

En este capítulo se presenta el método propuesto para agrupar redes a través de la firma orbital de sus nodos y que, así, toma en cuenta los roles estructurales de los usuarios. El método tiene dos etapas principales. Primero construye perfiles de usuarios utilizando la firma orbital de cada nodo en un análisis basado en \textit{graphlets}. Después, agrupa las redes con base en la distribución de perfiles de nodos que presentan. 

\section{Graphlets y órbitas dirigidas}
Sarajilic \textit{et al.} propusieron extender la idea una firma orbital a grafos dirigidos \cite{sarajlic_graphlet-based_2016}. Dada la cantidad de posibles configuraciones para las órbitas en un \textit{graphlet} dirigido, los autores limitan el conteo a \textit{graphlets} de hasta 4 nodos. Con estas consideraciones, la firma orbital resultante para cada nodo es un vector en $R^{129}$ donde el componente $i$ representa el conteo de la órbita $i$, de acuerdo a la descripción presentada en la Fig. \ref{fig:orbits}.

 \begin{figure}[htbp]
   \centering
   \includesvg[width=0.9\textwidth]{figures/orbits.svg}
    \caption{Órbitas en \textit{graphlets} de hasta 4 nodos. El subgrafo $G_i$ representa un \textit{graphlet} en la colección; las órbitas dentro de cada \textit{graphlet} están enumeradas para futuras referencias en este trabajo. }
    \label{fig:orbits}
\end{figure}


\section{Perfilar usuarios}\label{sec:proposal:users}
 La creación de perfiles de usuario (\textit{user profiling}) ha tenido numerosas aplicaciones dentro y fuera de las ciencias computacionales. Existen metodologías que permiten encontrar perfiles de usuario a partir de minería de datos en redes sociales, de modo que los perfiles representan ciertos rasgos psicológicos con sus conductas asociadas y hacen posible, entre otras cosas, campañas de marketing dirigidas \cite{hu_cambridge_2020}. Estos métodos para crear perfiles o grupos de usuarios comúnmente se basan en los metadatos de las interacciones entre usuarios.
 
Como se ilustró en la sección \ref{section:nodeclustering}, es posible realizar agrupamientos en una red basados en los diversos roles estructurales de los nodos que la componen. En el caso de una red social, esta tarea nos permite agrupar los distintos comportamientos de los usuarios a partir del papel que desempeñan y, por lo tanto, crear perfiles de usuarios con comportamientos y funciones en la red similares.
 
En las redes sociales, y específicamente en Twitter, las funciones y las interacciones que realiza un nodo dentro de una red inciden directamente en la composición y topología de la misma. Estudiar roles estructurales permite caracterizar nodos de acuerdo a su función, obtener información sobre los tipos de comportamiento de los usuarios y estudiar la composición de la red.

De hecho, diferentes trabajos en ciencias sociales se centran en los patrones de asociación en una red para entender los procesos dentro de un sistema. Por ejemplo, Lusher y Robins sugieren la presencia de configuraciones a lo largo de las líneas de \enquote{huellas arqueológicas} impresas en los mecanismos sociales a través del tiempo y ejemplifican su idea sugiriendo los arreglos mostrados en la Fig. \ref{fig:lusher}.

\begin{figure}[htbp]
  \centering
  \includesvg[width=1.\textwidth]{figures/LusherUnderstanding.svg}
    \caption{Algunos patrones propuestos por Lusher y Robins para describir configuraciones sociales dentro de procesos colectivos \citep{lusher_exponential_nodate}. Las aristas dirigidas permiten la distinción entre jerarquías y posiciones de poder dentro de la red.}
    \label{fig:lusher}
\end{figure}

Una propuesta de esta tesis es que, en el contexto de redes sociales, la firma orbital de un nodo basada en \textit{graphlets} podría analizarse como extensión del trabajo de Lusher y Robins. Es decir, proponemos considerar estructuras que van más allá de las triadas de usuarios con el fin de capturar información sobre las dinámicas sociales, la jerarquía que se establece entre personas y la estructura general de la red. 

Así, consideramos que en el caso de Twitter es posible identificar perfiles de usuarios similares dentro de las redes temáticas. Debido a la capacidad de las órbitas de capturar información sobre las posiciones y roles estructurales de un nodo dentro de una red, proponemos agrupar los nodos (usuarios) de la red temática utilizando la firma orbital como un \textit{embedding} para crear perfiles de usuarios.

Las redes temáticas de Twitter son redes con aristas dirigidas. En el estudio propuesto de las órbitas, consideramos aquellas que aparecen en \textit{graphlets} de orden 2-4, de acuerdo al trabajo de Sarajilic \textit{et al.} descrito en la sección anterior.  Por lo tanto, al realizar el conteo de órbitas dirigidas para cada nodo, se obtiene una matriz $M$ de tamaño $n_{users}\times 129$, en donde cada fila representa un nodo en la red. 

%[PÁRRAFO QUE TERMINA HABLANDO SOBRE EL VOLUMEN QUE SE ESPERA, Y POR QUÉ SERÍA NECESARIO UTILIZAR UNA VARIANTE MÁS EFICIENTE DE K-MEANS (MOTIVAR LA SIGUIENTE SUBSECCIÓN)]

Identificar los distintos perfiles a partir de la matriz $M$ requiere una tarea de agrupamiento. 
Aunque KMeans (Algoritmo \ref{algorithms:k-means}) es conveniente por motivos como la interpretabilidad, el volumen de datos en nuestro problema demanda un método más eficiente, considerando que se desea analizar la representación vectorial de todos los usuarios en todas las redes en la colección. Por esta razón, proponemos el uso de MiniBatch KMeans \cite{sculley_web-scale_2010}, que es una de las distintas modificaciones de KMeans propuestas para lidiar con limitaciones de tiempo y memoria. El algoritmo se describe a continuación. 

\subsection{MiniBatch KMeans}
A pesar de la enorme popularidad de KMeans por su simplicidad y buen desempeño, el algoritmo se ve limitado frente a la cada vez más grande cantidad de datos a analizar. Esto se debe a restricciones como tener que mantener todo el conjunto de datos en memoria. 

MiniBatch KMeans \cite{sculley_web-scale_2010} es una versión modificada de KMeans que busca reducir la complejidad computacional del algoritmo original utilizando únicamente una fracción del conjunto de datos en cada iteración. Esta estrategia reduce el número de cálculos de distancias por iteración y por lo tanto la complejidad total, pero con un costo asociado de un agrupamiento de menor calidad \cite{bejar_k-means_nodate}.

La idea principal de MiniBatch KMeans es utilizar pequeños lotes (mini batches) aleatorios de un tamaño fijo del conjunto de datos para poder almacenarlos en la memoria. En cada iteración se obtiene una nueva muestra aleatoria del conjunto de datos y se utiliza para actualizar los grupos (clusters) hasta la convergencia. 

MiniBatch KMeans hace uso de una tasa de aprendizaje que disminuye con el número de iteraciones. La tasa de aprendizaje es inversa del número de ejemplos asignados a un grupo durante el proceso y por lo tanto a medida que aumenta el número de iteraciones se reduce el efecto de nuevos ejemplos. La convergencia del algoritmo se puede detectar cuando no se producen más cambios en los grupos durante un número definido de iteraciones continuas. 

El Algoritmo \ref{algorithms:minik-means} muestra el pseudocódigo de MiniBatch KMeans y sus particularidades, entre ellas el muestreo $M$ de ejemplos aleatorios y el cálculo de la función objetivo (distorsión).

\include{codes/minikmeans}\label{algorithms:minik-means}

\subsection{Análisis de los perfiles identificados}

Para caracterizar el rol de los usuarios, consideramos las propiedades topológicas de las órbitas dominantes de los grupos y el papel que desempeñan en el \textit{graphlet} al que pertenecen. También proponemos revisar las órbitas ausentes en los grupos, es decir, las órbitas ausentes en todos los usuarios de un grupo establecido.

Algunas definiciones serán útiles para interpretar el rol que desempeñan las órbitas en un \textit{graphlet} específico. Es conveniente recordar que cada arista dirigida indica una relación entre dos nodos, donde el nodo inicial representa a un usuario que ha mencionado, respondido o retuiteado al usuario representado por el nodo final. 

\begin{itemize}
    \item Grado de entrada: Para un nodo $n$ de un \textit{graphlet}, el número de aristas dirigidass que terminan en él se denomina grado de entrada (\textit{in-degree}) de $n$. Se denota como $indegree(n)$
    \item Grado de salida: El número de aristas dirigidas que comienzan en el nodo de grafo es su grado de salida (\textit{out-degree}). Se denota como $outdegree(n)$.
    \item Fuente: Un nodo se considera una fuente en un grafo si tiene un grado \textit{in-degree} de 0. Es decir, $n$ tal que $indegree(n)=0$. 
    \item Pozo: Un nodo $n$ tal que $outdegree(n)=0$.
    \item Camino dirigido en un \textit{graphlet}: Una secuencia finita de aristas en una secuencia de distintos nodos de tal manera que todas las aristas tengan la misma dirección. Es fácil observar que cada camino maximal en un \textit{graphlet} comienza en una fuente y termina en un pozo. %Entender bien bien!
\end{itemize}

Dado que el grado de entrada y el grado de salida de un nodo son invariantes bajo una simetría, podemos extender las definiciones de fuente y de pozo de los nodos a las órbitas. 

Considerando las relaciones establecidas anteriormente respecto a las posibles interacciones en \textit{Twitter} (Ver. \ref{interacciones_twitter} se pueden establecer roles en función de las órbitas.

Podemos decir que una órbita fuente $\mathcal{O}$ es un oyente (\emph{listener}) si para cada nodo $n\in\mathcal{O}$, la longitud de cada camino maximal que contiene un nodo comenzando en $n$ es igual a 1. Las órbitas 0, 6, 7, 21, 23, y 29 son ejemplos de órbitas de oyentes, pero las órbitas 11 y 17 no lo son. (Ver Fig. \ref{fig:orbits})

De manera similar podemos decir que una órbita pozo $\mathcal{O}$ es un hablante (\emph{speaker}) si para cada otro nodo $n\in\mathcal{O}$, $n$ es un pozo con $indegree(n) > 1$. 

Finalmente podemos decir que una órbita $\mathcal{O}$ es una audiencia (\emph{audience}) si para cada nodo $n\in\mathcal{O}$, $n$ es un oyente y cada otro nodo $m$ en una arista que comienza en $n$ es un hablante, es decir un pozo con $indegree(m) > 1$. Las órbitas 7, 21 y 29 son ejemplos de órbitas de audiencia, pero la órbita 23 no lo es. (Ver Fig. \ref{fig:orbits})

Cada nodo $n$ participa en diferentes \textit{graphlets} dentro de un red; cada \textit{graphlet} nos da información sobre el vecindario local de 2, 3, o 4 nodos en los que $n$ participa. Adicionalmente, la información proporcionada por distintos \textit{graphlets} es diferente a aquella dada únicamente por el $indegree(n)$ o $outdegree(n)$. Por ejemplo, es posible distinguir las órbitas 0 y 29 reconociendo que pueden frecuentemente participar en distintos roles dentro de la estructura general de la red (ver Fig. \ref{fig:orbits}) que nos permitirá distinguir entre dos de los perfiles que se describirán en la sección de resultados.

% Sección de estabilidad se va al capítulo de experimentos
\subsection{Estabilidad de los perfiles identificados}
\label{NMI}

A la similitud entre distintas particiones generadas para un conjunto de datos, la llamaremos la estabilidad de la solución. Mientras más robusta es una estructura de organización en una colección, más parecidos son los agrupamientos resultantes de distintas corridas, con distintas inicializaciones.

Se puede estimar la estabilidad de la solución utilizando la Información Mutua Normalizada (NMI).

La información mutua de dos variables aleatorias mide la dependencia estadística entre ambas variables. Es decir, mide la información o reducción de la incertidumbre (entropía) de una variable aleatoria, $X$, debido al conocimiento del valor de otra variable aleatoria $Y$.

Consideremos dos variables aleatorias $X$ e $Y$ con posibles valores $x_i$, $i=1,2,...,n$, $y_j$, $j=1,2,...,m$ respectivamente. Dónde $$
{\displaystyle P(X=x_{i}|Y=y_{i})=P(x_{i}|y_{j})}$$ y $${\displaystyle P(X=x_{i})=P(x_{i})}$$

De manera formal la Información Mutua está definida como
$$ {\displaystyle I(x_{i};y_{j})=\log {\frac {P(x_{i}|y_{j})}{P(x_{i})}}} $$
y se puede obtener a partir de la entropía, que está definida como
$${\displaystyle H(X)=-\sum _{i}p(x_{i})\log _{2}p(x_{i})},$$
$${\displaystyle H(X,Y)=-\sum _{x,y}p(x,y)\log _{2}p(x,y)},$$
$${\displaystyle H(X|Y)=-\sum _{y}p(y)\sum _{x}p(x|y)\log _{2}p(x|y)}.$$

Para obtener la estabilidad de la solución en nuestro problema, corremos el algoritmo de agrupamiento de perfiles $R$ veces y obtenemos el promedio de los valores NMI para cada par de corridas del modelo. Es decir obtenemos una matriz de tamaño $R \times R$ donde $C_1,\ldots,C_r$ representan las corridas.

Formalmente, 
\begin{align}\label{eq:PNMI}
Stability(C_1,\ldots,C_r) &= \frac{1}{r(r-1)}\sum_{i,j,i\not=j}^{r}NMI(C_i,C_j) \\
 &= \frac{1}{r(r-1)}\sum_{i,j,i\not=j}^{r} \frac{\mathbb{I}(C_i,C_j)}{\sqrt{{H}(C_i){H}(C_j)}}
\end{align}
donde ${I}(C_i,C_j)$ es la NMI entre corridas $i,j$ y ${H}(C_i)$ denota la entropía de la $i$-ésima asignación.

Tomar en cuenta lo robusto del agrupamiento para diferentes valores iniciales de los centros en el algoritmo de agrupamiento permite estimar la confianza en los perfiles identificados para usuarios considerados en la colección. Esto es importante porque dichos perfiles representan la base de la siguiente fase. 

\section{Agrupar redes} \label{sec:system:sec3}
La segunda parte de la metodología se centra a agrupar las redes temáticas de la colección. Para ello, utilizamos una representación vectorial basada en los perfiles identificados en la primera parte de nuestro trabajo. De este modo, una vez que los perfiles de usuario se han establecido, creamos un segundo \textit{embedding} a partir de la frecuencia de aparición de cada tipo de usuario en cada una de las redes. 
Nuestra hipótesis es que la frecuencia de aparición de cada perfil de usuario en la red podría variar en función del interés suscitado por un tema y de la naturaleza de la discusión pública (colectiva) en Twitter. Así, cada red es representada por un vector $v$ en ${R}^k$ donde $k$ es el número de perfiles encontrados en el paso anterior y el componente $v_i$ es el conteo de usuarios con el perfil $i$ en esa red. 

Al representar cada red de acuerdo a la distribución de frecuencia de los tipos de usuario identificados en la fase 1, estamos sugiriendo que un criterio que permite diferenciar las redes en la colección es la dinámica que generan. 

\subsection{Agrupamiento jerárquico}
Una vez que se tiene la representación vectorial de cada red, utilizamos agrupamiento jerárquico para establecer la comparación entre redes. Este método permite analizar la estructura, en términos de distancia, de los grupos que surgen dentro del conjunto de datos considerando la representación basada en perfiles de usuario. 

En el agrupamiento jerárquico, la estructura, o jerarquía de grupos, se determina de manera avara y comúnmente se presenta en un dendrograma (Fig. \ref{fig:hierarchy}). Los resultados dependen de una medida de distancia entre las instancias del conjunto y un criterio de distancia para subconjuntos de datos. 

\begin{figure}[htbp]
  \centering
  \includesvg[width=0.5\textwidth]{figures/hierarchy.svg}
    \caption{Ejemplo de dendrograma asociado al agrupamiento jerárquico.}
    \label{fig:hierarchy}
\end{figure}

Una vez calculada la matriz de distancias entre instancias, los grupos se forman de acuerdo a alguno de los distintos criterios para calcular la distancia $d(u,v)$ entre dos grupos $u$ y $v$; los criterios más comunes se muestran en la Tabla \ref{tabla:criterios}. El algoritmo que utilizamos, con un enfoque aglomerativo, comienza considerando cada instancia un grupo. En cada paso, la pareja de clústers $u$ y $v$ con mínima distancia entre ellos se unirá para formar un nuevo cluster $w$. El algoritmo termina cuando solo queda un único cluster al que llamamos raíz.

\begin{table}
\caption{{Criterios de encadenamiento ($linkage$) para calcular la distancia entre dos grupos en el agrupamiento jerárquico aglomerativo.}}
\label{tabla:criterios}
    \begin{tabular}{ |p{2cm}|p{11cm}| }
    \hline
    Nombre & Función \\
    \hline
        \textit{Single} & $$d(u,v) =  \min(dist(u[i],v[j]))$$ \\
    \hline
        \textit{Complete} & $$d(u, v) = \max(dist(u[i],v[j]))$$  \\
    \hline
        \textit{Average}  & $$d(u,v) = \sum_{ij} \frac{d(u[i], v[j])}{(|u|*|v|)}$$ \\
    \hline
        \textit{Weighted} & $$d(u,v) = \frac{dist(s,v) + dist(t,v) }{2}$$ \\
    \hline
        \textit{Centroid} & $${d(u,v) = \|c_s - c_t\|}_2$$ \\
    \hline
        \textit{Ward} & $$d(u,v) = \sqrt{\frac{|v|+|s|}{T}d(v,s)^2+\frac{|v|+|t|}{T}d(v,t)^2- \frac{|v|}{T}d(s,t)^2}$$ dónde $T=|v|+|s|+|t|$ \\
    \hline
    \end{tabular}
\end{table}

Para nuestro problema, la distancia entre instancias se calcula usando la norma L2, definida formalmente como
$${\displaystyle \|{\boldsymbol {x}}\|_{2}:={\sqrt {x_{1}^{2}+\cdots +x_{n}^{2}}}.}$$

\section{Resumen}
La metodología propuesta en este capítulo permite agrupar redes temáticas en Twitter de una forma guiada por los datos, interpretable y basada en el comportamiento que cada tema genera. La Fig. \ref{fig:masterplan} muestra un esquema general del método propuesto. 
 
\begin{figure}[htbp]
   \centering
   \includesvg[width=0.75\textwidth]{figures/plan.svg}
    \caption{Resumen de la metodología propuesta.}
    \label{fig:masterplan}
\end{figure}




